# {{PROJECT_NAME_PASCAL}}

A production-ready Rust CLI application built with **Scarff** using layered architecture.

---

## üìã Overview

{{PROJECT_NAME}} is a command-line application built with modern Rust practices and a clean layered architecture that
separates concerns and makes the codebase maintainable and testable.

**Generated**: {{YEAR}}
**Language**: Rust (Edition 2021)
**Architecture**: Layered
**Template**: `rust-cli-layered@1.0.0`

---

## üèóÔ∏è Architecture

This project follows a **Layered Architecture** pattern:

```
{{PROJECT_NAME_KEBAB}}/
‚îú‚îÄ‚îÄ src/
‚îÇ ‚îú‚îÄ‚îÄ cli/ # CLI layer (argument parsing, commands)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ mod.rs
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ commands.rs
‚îÇ ‚îú‚îÄ‚îÄ application/ # Application layer (business logic orchestration)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ mod.rs
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ services.rs
‚îÇ ‚îú‚îÄ‚îÄ domain/ # Domain layer (core business logic)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ mod.rs
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ models.rs
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ errors.rs
‚îÇ ‚îú‚îÄ‚îÄ infrastructure/ # Infrastructure layer (external concerns)
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ mod.rs
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ config.rs
‚îÇ ‚îú‚îÄ‚îÄ main.rs # Application entry point
‚îÇ ‚îî‚îÄ‚îÄ lib.rs # Library root
‚îú‚îÄ‚îÄ tests/ # Integration tests
‚îÇ ‚îî‚îÄ‚îÄ integration_test.rs
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ README.md
```

### Layer Responsibilities

**CLI Layer** (`src/cli/`)
- Argument parsing with Clap
- Command routing
- User interaction
- Input validation

**Application Layer** (`src/application/`)
- Business logic orchestration
- Use case implementation
- Service coordination
- Transaction management

**Domain Layer** (`src/domain/`)
- Core business entities
- Domain logic
- Business rules
- Domain events

**Infrastructure Layer** (`src/infrastructure/`)
- Configuration management
- External API clients
- File system operations
- Database connections (when needed)

---

## üöÄ Quick Start

### Prerequisites

- **Rust 1.75+** - [Install Rust](https://rustup.rs/)
- **Cargo** (included with Rust)

### Installation

```bash
# Clone/navigate to your project
cd {{PROJECT_NAME_KEBAB}}

# Build the project
cargo build

# Run the application
cargo run

# Run with arguments
cargo run -- --help
```

### Running Tests

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test integration_test
```

### Development

```bash
# Check for errors
cargo check

# Format code
cargo fmt

# Lint with Clippy
cargo clippy

# Build for release
cargo build --release
```

---

## üì¶ Dependencies

This template uses carefully selected, production-ready crates:

### Core Dependencies

- **[clap](https://docs.rs/clap/4.5/) 4.5** - Command-line argument parsing
- Feature: `derive` - Derive macros for easy CLI definition

- **[anyhow](https://docs.rs/anyhow/1.0/) 1.0** - Flexible error handling
- Context-aware errors
- Error chaining

- **[thiserror](https://docs.rs/thiserror/1.0/) 1.0** - Custom error types
- Derive macros for `Error` trait

- **[tracing](https://docs.rs/tracing/0.1/) 0.1** - Structured logging
- Async-aware
- Multiple log levels

- **[tracing-subscriber](https://docs.rs/tracing-subscriber/0.3/) 0.3** - Log collection
- Feature: `env-filter` - Environment-based filtering
- Feature: `fmt` - Formatted output

### Development Dependencies

- **[assert_cmd](https://docs.rs/assert_cmd/) 2.0** - CLI testing utilities
- **[predicates](https://docs.rs/predicates/) 3.0** - Test assertions

---

## üîß Configuration

Configuration is managed through the `infrastructure/config.rs` module.

### Adding Configuration Options

```rust
// src/infrastructure/config.rs

#[derive(Debug, Clone)]
pub struct Config {
pub app_name: String,
pub verbose: bool,
// Add your config fields here
}

impl Config {
pub fn load() -> anyhow::Result<Self> {
  // Load from environment, files, etc.
  }
  }
  ```

  ### Using Configuration

  ```rust
  use crate::infrastructure::Config;

  pub fn run() -> anyhow::Result<()> {
    let config = Config::load()?;
    // Use config...
    }
    ```

    ---

    ## üß™ Testing Strategy

    ### Unit Tests

    Place unit tests in the same file as the code:

    ```rust
    // src/domain/models.rs

    #[cfg(test)]
    mod tests {
    use super::*;

    #[test]
    fn test_model_creation() {
    // Test code
    }
    }
    ```

    ### Integration Tests

    Place integration tests in `tests/`:

    ```rust
    // tests/integration_test.rs

    use assert_cmd::Command;

    #[test]
    fn test_cli_help() {
    let mut cmd = Command::cargo_bin(env!("CARGO_PKG_NAME")).unwrap();
    cmd.arg("--help").assert().success();
    }
    ```

    ---

    ## üìö Key Concepts

    ### Error Handling

    This template uses a layered error handling approach:

    **Domain Errors** (`domain/errors.rs`)
    ```rust
    use thiserror::Error;

    #[derive(Debug, Error)]
    pub enum DomainError {
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    }
    ```

    **Application Errors** (using `anyhow`)
    ```rust
    use anyhow::{Context, Result};

    pub fn process() -> Result<()> {
      some_operation()
      .context("Failed to process data")?;
      Ok(())
      }
      ```

      ### Logging

      Structured logging with tracing:

      ```rust
      use tracing::{info, error, debug};

      info!("Application started");
      debug!(value = %some_value, "Processing value");
      error!("Operation failed");
      ```

      ### Command Pattern

      Define commands in `cli/commands.rs`:

      ```rust
      use clap::Parser;

      #[derive(Parser)]
      pub enum Commands {
      /// Process a file
      Process {
      #[arg(short, long)]
      file: PathBuf,
      },
      }
      ```

      ---

      ## üéØ Common Tasks

      ### Adding a New Command

      1. **Define command in `cli/commands.rs`**:
      ```rust
      #[derive(Parser)]
      pub enum Commands {
      NewCommand {
      #[arg(short, long)]
      option: String,
      },
      }
      ```

      2. **Add handler logic**:
      ```rust
      // src/application/services.rs
      pub fn handle_new_command(option: &str) -> anyhow::Result<()> {
        // Implementation
        }
        ```

        3. **Wire it up in `main.rs`**:
        ```rust
        match cli.command {
        Commands::NewCommand { option } => {
        handle_new_command(&option)?;
        }
        }
        ```

        ### Adding a New Domain Model

        1. Create in `domain/models.rs`:
        ```rust
        pub struct MyModel {
        pub field: String,
        }
        ```

        2. Add business logic methods
        3. Add unit tests

        ### Adding External Dependencies

        1. Update `Cargo.toml`:
        ```toml
        [dependencies]
        new-crate = "1.0"
        ```

        2. Use in infrastructure layer
        3. Create abstractions in domain if needed

        ---

        ## üîê Best Practices

        ### ‚úÖ Do

        - Keep domain logic pure (no I/O, no frameworks)
        - Use the type system to enforce invariants
        - Write tests for business logic
        - Handle errors explicitly with `Result`
        - Use tracing for observability
        - Keep functions small and focused

        ### ‚ùå Don't

        - Put business logic in CLI layer
        - Use `unwrap()` or `expect()` in production code
        - Mix layers (e.g., domain calling infrastructure)
        - Ignore Clippy warnings
        - Skip documentation on public APIs

        ---

        ## üìñ Further Reading

        ### Rust Resources

        - [The Rust Programming Language](https://doc.rust-lang.org/book/) - Official book
        - [Rust by Example](https://doc.rust-lang.org/rust-by-example/) - Learn by doing
        - [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/) - API design
        - [Effective Rust](https://www.lurklurk.org/effective-rust/) - Best practices

        ### Architecture Patterns

        - [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) - Robert C.
        Martin
        - [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/) - Alistair Cockburn
        - [Domain-Driven Design](https://www.domainlanguage.com/ddd/) - Eric Evans

        ### Dependency Documentation

        - [Clap User Guide](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)
        - [Tracing Guide](https://tokio.rs/tokio/topics/tracing)
        - [Anyhow Documentation](https://docs.rs/anyhow/latest/anyhow/)

        ---

        ## ü§ù Contributing

        This project was generated by **Scarff** - a modern project scaffolding tool.

        ### Project Structure Guidelines

        When extending this project:

        1. **Respect layer boundaries** - Dependencies should flow inward
        2. **Keep domain pure** - No external dependencies in domain layer
        3. **Test thoroughly** - Maintain high test coverage
        4. **Document public APIs** - Use Rustdoc for all public items

        ### Upgrading Dependencies

        ```bash
        # Check for updates
        cargo outdated

        # Update Cargo.lock
        cargo update

        # Update dependencies in Cargo.toml
        # Then: cargo build
        ```

        ---

        ## üîÆ Future Enhancements (Optional)

        This template can be extended with:

        ### Persistence
        - Add SQLite with `rusqlite` or `sqlx`
        - Add file-based storage
        - Add caching layer

        ### Networking
        - HTTP client with `reqwest`
        - WebSocket support
        - gRPC with `tonic`

        ### Advanced CLI
        - Interactive prompts with `dialoguer`
        - Progress bars with `indicatif`
        - Colored output with `colored`

        ### Observability
        - Metrics with `metrics`
        - Distributed tracing
        - Log aggregation

        ### Deployment
        - Cross-compilation
        - Docker containerization
        - CI/CD pipelines (GitHub Actions, GitLab CI)

        ---

        ## üìÑ License

        [Your License Here]

        ---

        ## üôè Acknowledgments

        **Generated by**: [Scarff](https://github.com/yourusername/scarff) - Modern project scaffolding
        **Template Version**: 1.0.0
        **Generated**: {{YEAR}}

        ### Scarff Features Used

        - ‚úÖ Layered architecture pattern
        - ‚úÖ Modern Rust practices
        - ‚úÖ Comprehensive project structure
        - ‚úÖ Production-ready dependencies
        - ‚úÖ Testing setup
        - ‚úÖ Documentation templates

        ---

        ## üÜò Getting Help

        ### Issues with the Project

        - Check [Rust Documentation](https://doc.rust-lang.org/)
        - Visit [Rust Users Forum](https://users.rust-lang.org/)
        - Ask on [Rust Discord](https://discord.gg/rust-lang)

        ### Issues with Scarff

        - [Scarff Documentation](https://scarff.dev/docs)
        - [Scarff GitHub Issues](https://github.com/yourusername/scarff/issues)
        - [Scarff Discord Community](https://discord.gg/scarff)

        ---

        **Happy coding! ü¶Ä**
