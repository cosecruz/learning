//! Primary Adapter: CLI
//!
//! This is the "outside world" that drives the application core.
//! It depends on scarff-core (driving ports) and scarff-adapters (implementations).
//!
//! Hexagonal rule: Adapters depend on core. Core knows nothing about this file.

use clap::{Parser, Subcommand};
use miette::{Context, IntoDiagnostic, Result};
use scarff_adapters::{ConsoleNotifier, FileConfigProvider, SqliteRepository};
use scarff_core::{
    application::{EntityService, dto::EntityDto},
    domain::EntityId,
    ports::driven::{EntityRepository, Notifier, ConfigProvider, InMemoryRepository},
    ports::driving::EntityOperations,
};
use std::sync::Arc;
use tracing::{info, Level};

#[derive(Parser)]
#[command(
    name = "scarff",
    about = "Hexagonal CLI template",
    version,
    author,
    arg_required_else_help = true
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[arg(short, long, global = true)]
    config: Option<String>,

    #[arg(short, long, global = true, default_value = "info")]
    log_level: String,

    #[arg(long, global = true)]
    no_color: bool,

    #[arg(long, global = true)]
    memory: bool,
}

#[derive(Subcommand)]
enum Commands {
    Create {
        name: String,
        #[arg(short, long)]
        metadata: Option<String>,
    },
    List,
    Get {
        id: String,
    },
    Archive {
        id: String,
    },
    Activate {
        id: String,
    },
    Rename {
        id: String,
        new_name: String,
    },
    Delete {
        id: String,
    },
    Completions {
        shell: clap_complete::Shell,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    // Setup tracing
    tracing_subscriber::fmt()
        .with_max_level(parse_log_level(&cli.log_level))
        .with_target(false)
        .init();

    info!("Scarff CLI starting");

    // Setup adapters (infrastructure)
    let config = FileConfigProvider::new()
        .into_diagnostic()
        .wrap_err("Config error")?;

    let data_dir = config.data_dir().await.into_diagnostic()?;
    let db_path = data_dir.join("scarff.db");

    // Repository (driven adapter)
    let repository: Arc<dyn EntityRepository> = if cli.memory {
        info!("Using in-memory repository");
        Arc::new(InMemoryRepository::new())
    } else {
        info!("Using SQLite repository: {:?}", db_path);
        let db_url = format!("sqlite://{}?mode=rwc", db_path.display());
        Arc::new(
            SqliteRepository::new(&db_url)
                .await
                .into_diagnostic()
                .wrap_err("Database connection failed")?
        )
    };

    // Notifier (driven adapter)
    let notifier: Option<Arc<dyn Notifier>> = if cli.no_color {
        None
    } else {
        Some(Arc::new(ConsoleNotifier::new(true)))
    };

    // Service (core - implements driving port)
    let service = EntityService::new(repository, notifier);

    // Route commands
    match cli.command {
        Commands::Create { name, metadata } => {
            let meta = metadata
                .map(|m| serde_json::from_str(&m).into_diagnostic())
                .transpose()?;

            let entity = service.create(name, meta).await.into_diagnostic()?;
            print_entity(&entity.into());
        }

        Commands::List => {
            let entities = service.list().await.into_diagnostic()?;
            if entities.is_empty() {
                println!("No entities found.");
            } else {
                for e in entities {
                    println!("{} - {} ({:?})", e.id, e.name, e.status);
                }
            }
        }

        Commands::Get { id } => {
            let uuid = EntityId::parse(&id).into_diagnostic()?;
            let entity = service.get(uuid).await.into_diagnostic()?;
            print_entity(&entity.into());
        }

        Commands::Archive { id } => {
            let uuid = EntityId::parse(&id).into_diagnostic()?;
            let entity = service.archive(uuid).await.into_diagnostic()?;
            print_entity(&entity.into());
        }

        Commands::Activate { id } => {
            let uuid = EntityId::parse(&id).into_diagnostic()?;
            let entity = service.activate(uuid).await.into_diagnostic()?;
            print_entity(&entity.into());
        }

        Commands::Rename { id, new_name } => {
            let uuid = EntityId::parse(&id).into_diagnostic()?;
            let entity = service.rename(uuid, new_name).await.into_diagnostic()?;
            print_entity(&entity.into());
        }

        Commands::Delete { id } => {
            let uuid = EntityId::parse(&id).into_diagnostic()?;
            service.delete(uuid).await.into_diagnostic()?;
            println!("Deleted {}", id);
        }

        Commands::Completions { shell } => {
            let mut cmd = Cli::command();
            clap_complete::generate(shell, &mut cmd, "scarff", &mut std::io::stdout());
        }
    }

    Ok(())
}

fn parse_log_level(level: &str) -> Level {
    match level.to_lowercase().as_str() {
        "trace" => Level::TRACE,
        "debug" => Level::DEBUG,
        "info" => Level::INFO,
        "warn" => Level::WARN,
        "error" => Level::ERROR,
        _ => Level::INFO,
    }
}

fn print_entity(dto: &EntityDto) {
    println!("ID:        {}", dto.id);
    println!("Name:      {}", dto.name);
    println!("Status:    {}", dto.status);
    println!("Created:   {}", dto.created_at);
    println!("Updated:   {}", dto.updated_at);
    if dto.metadata != serde_json::Value::Null {
        println!("Metadata:  {}", dto.metadata);
    }
}
