use async_trait::async_trait;
use console::{style, Term};
use scarff_core::ports::driven::Notifier;
use std::sync::Arc;
use tokio::sync::Mutex;

/// Console adapter implementing the Notifier port.
pub struct ConsoleNotifier {
    term: Arc<Mutex<Term>>,
    use_color: bool,
}

impl ConsoleNotifier {
    pub fn new(use_color: bool) -> Self {
        Self {
            term: Arc::new(Mutex::new(Term::stdout())),
            use_color,
        }
    }
}

#[async_trait]
impl Notifier for ConsoleNotifier {
    async fn success(&self, message: &str) {
        let term = self.term.lock().await;
        if self.use_color {
            let _ = term.write_line(&format!("{} {}", style("✓").green().bold(), message));
        } else {
            let _ = term.write_line(&format!("[OK] {}", message));
        }
    }

    async fn error(&self, message: &str) {
        let term = self.term.lock().await;
        if self.use_color {
            let _ = term.write_line(&format!("{} {}", style("✗").red().bold(), message));
        } else {
            let _ = term.write_line(&format!("[ERR] {}", message));
        }
    }

    async fn info(&self, message: &str) {
        let term = self.term.lock().await;
        if self.use_color {
            let _ = term.write_line(&format!("{} {}", style("ℹ").blue(), message));
        } else {
            let _ = term.write_line(&format!("[INFO] {}", message));
        }
    }

    async fn progress(&self, message: &str, current: usize, total: usize) {
        let term = self.term.lock().await;
        let pct = (current as f64 / total as f64 * 100.0) as usize;
        let _ = term.write_line(&format!("[{}/{}] {}% - {}", current, total, pct, message));
    }
}
