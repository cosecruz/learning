//! Use case implementations and service facade.
//!
//! Each use case is a single responsibility operation.
//! EntityService combines them into the driving port implementation.

use crate::domain::{DomainError, Entity, EntityId};
use crate::ports::driven::{EntityRepository, Notifier};
use crate::ports::driving::EntityOperations;
use async_trait::async_trait;
use std::sync::Arc;

/// Individual use case: Create entity.
pub struct CreateEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl CreateEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, name: String, metadata: Option<serde_json::Value>) -> Result<Entity, DomainError> {
        if name.trim().is_empty() {
            return Err(DomainError::Validation("Name required".to_string()));
        }

        let mut entity = Entity::new(name);
        if let Some(meta) = metadata {
            entity.metadata = meta;
        }

        self.repo.save(&entity).await?;
        Ok(entity)
    }
}

/// Individual use case: List all entities.
pub struct ListEntitiesUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl ListEntitiesUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self) -> Result<Vec<Entity>, DomainError> {
        self.repo.find_all().await
    }
}

/// Individual use case: Get single entity.
pub struct GetEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl GetEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, id: EntityId) -> Result<Entity, DomainError> {
        self.repo.find_by_id(id).await?
            .ok_or(DomainError::EntityNotFound(id))
    }
}

/// Individual use case: Archive entity.
pub struct ArchiveEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl ArchiveEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, id: EntityId) -> Result<Entity, DomainError> {
        let mut entity = self.repo.find_by_id(id).await?
            .ok_or(DomainError::EntityNotFound(id))?;

        entity.archive()?;
        self.repo.save(&entity).await?;
        Ok(entity)
    }
}

/// Individual use case: Activate entity.
pub struct ActivateEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl ActivateEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, id: EntityId) -> Result<Entity, DomainError> {
        let mut entity = self.repo.find_by_id(id).await?
            .ok_or(DomainError::EntityNotFound(id))?;

        entity.activate()?;
        self.repo.save(&entity).await?;
        Ok(entity)
    }
}

/// Individual use case: Rename entity.
pub struct RenameEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl RenameEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, id: EntityId, new_name: String) -> Result<Entity, DomainError> {
        let mut entity = self.repo.find_by_id(id).await?
            .ok_or(DomainError::EntityNotFound(id))?;

        entity.rename(new_name)?;
        self.repo.save(&entity).await?;
        Ok(entity)
    }
}

/// Individual use case: Delete entity.
pub struct DeleteEntityUseCase {
    repo: Arc<dyn EntityRepository>,
}

impl DeleteEntityUseCase {
    pub fn new(repo: Arc<dyn EntityRepository>) -> Self {
        Self { repo }
    }

    pub async fn execute(&self, id: EntityId) -> Result<(), DomainError> {
        // Verify exists first
        if !self.repo.exists(id).await? {
            return Err(DomainError::EntityNotFound(id));
        }
        self.repo.delete(id).await
    }
}

/// Main service implementing the driving port.
/// Composes all use cases and adds cross-cutting concerns (logging, notifications).
pub struct EntityService {
    create: CreateEntityUseCase,
    list: ListEntitiesUseCase,
    get: GetEntityUseCase,
    archive: ArchiveEntityUseCase,
    activate: ActivateEntityUseCase,
    rename: RenameEntityUseCase,
    delete: DeleteEntityUseCase,
    notifier: Option<Arc<dyn Notifier>>,
}

impl EntityService {
    pub fn new(
        repo: Arc<dyn EntityRepository>,
        notifier: Option<Arc<dyn Notifier>>,
    ) -> Self {
        Self {
            create: CreateEntityUseCase::new(repo.clone()),
            list: ListEntitiesUseCase::new(repo.clone()),
            get: GetEntityUseCase::new(repo.clone()),
            archive: ArchiveEntityUseCase::new(repo.clone()),
            activate: ActivateEntityUseCase::new(repo.clone()),
            rename: RenameEntityUseCase::new(repo.clone()),
            delete: DeleteEntityUseCase::new(repo.clone()),
            notifier,
        }
    }

    async fn notify_success(&self, msg: &str) {
        if let Some(n) = &self.notifier {
            n.success(msg).await;
        }
    }

    async fn notify_error(&self, msg: &str) {
        if let Some(n) = &self.notifier {
            n.error(msg).await;
        }
    }
}

#[async_trait]
impl EntityOperations for EntityService {
    async fn create(&self, name: String, metadata: Option<serde_json::Value>) -> Result<Entity, DomainError> {
        let result = self.create.execute(name, metadata).await;
        match &result {
            Ok(e) => self.notify_success(&format!("Created entity {}", e.id)).await,
            Err(e) => self.notify_error(&format!("Failed to create: {}", e)).await,
        }
        result
    }

    async fn list(&self) -> Result<Vec<Entity>, DomainError> {
        self.list.execute().await
    }

    async fn get(&self, id: EntityId) -> Result<Entity, DomainError> {
        self.get.execute(id).await
    }

    async fn archive(&self, id: EntityId) -> Result<Entity, DomainError> {
        let result = self.archive.execute(id).await;
        match &result {
            Ok(e) => self.notify_success(&format!("Archived entity {}", e.id)).await,
            Err(e) => self.notify_error(&format!("Failed to archive: {}", e)).await,
        }
        result
    }

    async fn activate(&self, id: EntityId) -> Result<Entity, DomainError> {
        let result = self.activate.execute(id).await;
        match &result {
            Ok(e) => self.notify_success(&format!("Activated entity {}", e.id)).await,
            Err(e) => self.notify_error(&format!("Failed to activate: {}", e)).await,
        }
        result
    }

    async fn rename(&self, id: EntityId, new_name: String) -> Result<Entity, DomainError> {
        self.rename.execute(id, new_name).await
    }

    async fn delete(&self, id: EntityId) -> Result<(), DomainError> {
        let result = self.delete.execute(id).await;
        match &result {
            Ok(_) => self.notify_success(&format!("Deleted entity {}", id)).await,
            Err(e) => self.notify_error(&format!("Failed to delete: {}", e)).await,
        }
        result
    }
}
