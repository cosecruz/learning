use super::{EntityId, DomainError};
use std::time::SystemTime;

/// Core domain entity with business rules.
#[derive(Debug, Clone, PartialEq)]
pub struct Entity {
    pub id: EntityId,
    pub name: String,
    pub status: Status,
    pub created_at: SystemTime,
    pub updated_at: SystemTime,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Status {
    Draft,
    Active,
    Archived,
}

impl Entity {
    pub fn new(name: impl Into<String>) -> Self {
        let now = SystemTime::now();
        Self {
            id: EntityId::new(),
            name: name.into(),
            status: Status::Draft,
            created_at: now,
            updated_at: now,
            metadata: serde_json::Value::Null,
        }
    }

    pub fn activate(&mut self) -> Result<(), DomainError> {
        match self.status {
            Status::Archived => Err(DomainError::InvalidStateTransition {
                from: "Archived".to_string(),
                to: "Active".to_string(),
            }),
            Status::Active => Ok(()), // Idempotent
            Status::Draft => {
                self.status = Status::Active;
                self.updated_at = SystemTime::now();
                Ok(())
            }
        }
    }

    pub fn archive(&mut self) -> Result<(), DomainError> {
        if self.status == Status::Archived {
            return Ok(()); // Idempotent
        }
        self.status = Status::Archived;
        self.updated_at = SystemTime::now();
        Ok(())
    }

    pub fn rename(&mut self, new_name: impl Into<String>) -> Result<(), DomainError> {
        let name = new_name.into();
        if name.trim().is_empty() {
            return Err(DomainError::Validation("Name cannot be empty".to_string()));
        }
        if name.len() > 100 {
            return Err(DomainError::Validation("Name too long (max 100)".to_string()));
        }
        self.name = name;
        self.updated_at = SystemTime::now();
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn entity_lifecycle() {
        let mut entity = Entity::new("Test");
        assert_eq!(entity.status, Status::Draft);

        entity.activate().unwrap();
        assert_eq!(entity.status, Status::Active);

        entity.archive().unwrap();
        assert_eq!(entity.status, Status::Archived);

        // Cannot activate archived
        assert!(entity.activate().is_err());
    }

    #[test]
    fn empty_name_fails() {
        let mut entity = Entity::new("Valid");
        assert!(entity.rename("").is_err());
        assert!(entity.rename("   ").is_err());
    }
}
