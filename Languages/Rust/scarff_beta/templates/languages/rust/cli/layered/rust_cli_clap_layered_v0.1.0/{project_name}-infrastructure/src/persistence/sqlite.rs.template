use async_trait::async_trait;
use scarff_core::domain::{Entity, Repository, Error as DomainError, Status};
use sqlx::{sqlite::SqlitePoolOptions, Pool, Sqlite, Row};
use std::str::FromStr;
use tracing::{info, instrument};
use uuid::Uuid;

/// SQLite implementation of the Repository trait.
pub struct SqliteRepository {
    pool: Pool<Sqlite>,
}

impl SqliteRepository {
    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {
        info!("Connecting to SQLite database: {}", database_url);

        let pool = SqlitePoolOptions::new()
            .max_connections(5)
            .connect(database_url)
            .await?;

        // Run migrations
        sqlx::migrate!("./migrations")
            .run(&pool)
            .await?;

        Ok(Self { pool })
    }

    pub async fn close(&self) {
        self.pool.close().await;
    }
}

#[async_trait]
impl Repository for SqliteRepository {
    #[instrument(skip(self))]
    async fn find_by_id(&self, id: Uuid) -> Result<Option<Entity>, DomainError> {
        let row = sqlx::query(
            r#"
            SELECT id, name, status, created_at, updated_at, metadata
            FROM entities
            WHERE id = ?
            "#
        )
        .bind(id.to_string())
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| DomainError::Validation(format!("Database error: {}", e)))?;

        Ok(row.map(|r| Entity {
            id: Uuid::parse_str(r.get::<String, _>("id")).unwrap_or_default(),
            name: r.get("name"),
            status: Status::from_str(r.get::<String, _>("status")).unwrap_or(Status::Pending),
            created_at: r.get("created_at"),
            updated_at: r.get("updated_at"),
            metadata: serde_json::from_str(r.get::<String, _>("metadata")).unwrap_or_default(),
        }))
    }

    #[instrument(skip(self))]
    async fn find_all(&self) -> Result<Vec<Entity>, DomainError> {
        let rows = sqlx::query(
            r#"
            SELECT id, name, status, created_at, updated_at, metadata
            FROM entities
            ORDER BY created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| DomainError::Validation(format!("Database error: {}", e)))?;

        Ok(rows.into_iter().map(|r| Entity {
            id: Uuid::parse_str(r.get::<String, _>("id")).unwrap_or_default(),
            name: r.get("name"),
            status: Status::from_str(r.get::<String, _>("status")).unwrap_or(Status::Pending),
            created_at: r.get("created_at"),
            updated_at: r.get("updated_at"),
            metadata: serde_json::from_str(r.get::<String, _>("metadata")).unwrap_or_default(),
        }).collect())
    }

    #[instrument(skip(self, entity))]
    async fn save(&self, entity: &Entity) -> Result<(), DomainError> {
        sqlx::query(
            r#"
            INSERT INTO entities (id, name, status, created_at, updated_at, metadata)
            VALUES (?1, ?2, ?3, ?4, ?5, ?6)
            ON CONFLICT(id) DO UPDATE SET
                name = excluded.name,
                status = excluded.status,
                updated_at = excluded.updated_at,
                metadata = excluded.metadata
            "#
        )
        .bind(entity.id.to_string())
        .bind(&entity.name)
        .bind(format!("{:?}", entity.status))
        .bind(entity.created_at)
        .bind(entity.updated_at)
        .bind(entity.metadata.to_string())
        .execute(&self.pool)
        .await
        .map_err(|e| DomainError::Validation(format!("Database error: {}", e)))?;

        Ok(())
    }

    #[instrument(skip(self))]
    async fn delete(&self, id: Uuid) -> Result<(), DomainError> {
        sqlx::query("DELETE FROM entities WHERE id = ?")
            .bind(id.to_string())
            .execute(&self.pool)
            .await
            .map_err(|e| DomainError::Validation(format!("Database error: {}", e)))?;

        Ok(())
    }
}
