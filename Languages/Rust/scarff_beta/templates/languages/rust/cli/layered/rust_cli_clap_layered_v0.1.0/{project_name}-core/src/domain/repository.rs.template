use async_trait::async_trait;
use super::Entity;
use std::collections::HashMap;
use uuid::Uuid;

/// Repository trait â€” defines the contract for persistence.
/// Infrastructure layer will provide concrete implementations.
#[async_trait]
pub trait Repository: Send + Sync {
    async fn find_by_id(&self, id: Uuid) -> Result<Option<Entity>, super::Error>;
    async fn find_all(&self) -> Result<Vec<Entity>, super::Error>;
    async fn save(&self, entity: &Entity) -> Result<(), super::Error>;
    async fn delete(&self, id: Uuid) -> Result<(), super::Error>;
}

/// In-memory implementation for testing and development.
pub struct InMemoryRepository {
    storage: std::sync::RwLock<HashMap<Uuid, Entity>>,
}

impl InMemoryRepository {
    pub fn new() -> Self {
        Self {
            storage: std::sync::RwLock::new(HashMap::new()),
        }
    }
}

impl Default for InMemoryRepository {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl Repository for InMemoryRepository {
    async fn find_by_id(&self, id: Uuid) -> Result<Option<Entity>, super::Error> {
        let storage = self.storage.read().unwrap();
        Ok(storage.get(&id).cloned())
    }

    async fn find_all(&self) -> Result<Vec<Entity>, super::Error> {
        let storage = self.storage.read().unwrap();
        Ok(storage.values().cloned().collect())
    }

    async fn save(&self, entity: &Entity) -> Result<(), super::Error> {
        let mut storage = self.storage.write().unwrap();
        storage.insert(entity.id, entity.clone());
        Ok(())
    }

    async fn delete(&self, id: Uuid) -> Result<(), super::Error> {
        let mut storage = self.storage.write().unwrap();
        storage.remove(&id);
        Ok(())
    }
}
