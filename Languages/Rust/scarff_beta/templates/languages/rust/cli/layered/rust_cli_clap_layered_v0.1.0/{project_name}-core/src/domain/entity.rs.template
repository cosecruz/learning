use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Example domain entity. Replace with your actual business concept.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Entity {
    pub id: Uuid,
    pub name: String,
    pub status: Status,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Status {
    Pending,
    Active,
    Suspended,
    Archived,
}

impl Entity {
    pub fn new(name: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            status: Status::Pending,
            created_at: now,
            updated_at: now,
            metadata: serde_json::Value::Null,
        }
    }

    pub fn activate(&mut self) -> Result<(), super::Error> {
        match self.status {
            Status::Archived => Err(super::Error::InvalidState {
                from: "Archived".to_string(),
                to: "Active".to_string(),
            }),
            Status::Active => Ok(()), // Idempotent
            _ => {
                self.status = Status::Active;
                self.updated_at = Utc::now();
                Ok(())
            }
        }
    }

    pub fn archive(&mut self) -> Result<(), super::Error> {
        self.status = Status::Archived;
        self.updated_at = Utc::now();
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn entity_lifecycle() {
        let mut entity = Entity::new("Test");
        assert_eq!(entity.status, Status::Pending);

        entity.activate().unwrap();
        assert_eq!(entity.status, Status::Active);

        entity.archive().unwrap();
        assert_eq!(entity.status, Status::Archived);

        // Cannot activate archived entity
        assert!(entity.activate().is_err());
    }
}
