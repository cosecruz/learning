use crate::domain::{Entity, Repository, Error as DomainError};
use super::{Context, dto::{EntityDto, CreateEntityRequest}};
use async_trait::async_trait;
use tracing::{info, instrument};
use uuid::Uuid;

/// Trait for use cases to enable testing and composition.
#[async_trait]
pub trait UseCase<Input, Output> {
    async fn execute(&self, ctx: &Context, input: Input) -> Result<Output, DomainError>;
}

/// Create a new entity.
pub struct CreateEntity;

#[async_trait]
impl UseCase<CreateEntityRequest, EntityDto> for CreateEntity {
    #[instrument(skip(ctx, req), fields(entity_name = %req.name))]
    async fn execute(&self, ctx: &Context, req: CreateEntityRequest) -> Result<EntityDto, DomainError> {
        info!("Creating new entity");

        let mut entity = Entity::new(&req.name);
        if let Some(metadata) = req.metadata {
            entity.metadata = metadata;
        }

        ctx.repository.save(&entity).await?;

        Ok(EntityDto {
            id: entity.id,
            name: entity.name,
            status: format!("{:?}", entity.status),
            created_at: entity.created_at,
            updated_at: entity.updated_at,
        })
    }
}

/// List all entities.
pub struct ListEntities;

#[async_trait]
impl UseCase<(), Vec<EntityDto>> for ListEntities {
    #[instrument(skip(ctx))]
    async fn execute(&self, ctx: &Context, _: ()) -> Result<Vec<EntityDto>, DomainError> {
        let entities = ctx.repository.find_all().await?;

        Ok(entities.into_iter().map(|e| EntityDto {
            id: e.id,
            name: e.name,
            status: format!("{:?}", e.status),
            created_at: e.created_at,
            updated_at: e.updated_at,
        }).collect())
    }
}

/// Get a single entity by ID.
pub struct GetEntity;

#[async_trait]
impl UseCase<Uuid, EntityDto> for GetEntity {
    #[instrument(skip(ctx), fields(entity_id = %input))]
    async fn execute(&self, ctx: &Context, input: Uuid) -> Result<EntityDto, DomainError> {
        let entity = ctx.repository.find_by_id(input).await?
            .ok_or_else(|| DomainError::NotFound { id: input.to_string() })?;

        Ok(EntityDto {
            id: entity.id,
            name: entity.name,
            status: format!("{:?}", entity.status),
            created_at: entity.created_at,
            updated_at: entity.updated_at,
        })
    }
}

/// Archive an entity.
pub struct ArchiveEntity;

#[async_trait]
impl UseCase<Uuid, EntityDto> for ArchiveEntity {
    #[instrument(skip(ctx), fields(entity_id = %input))]
    async fn execute(&self, ctx: &Context, input: Uuid) -> Result<EntityDto, DomainError> {
        let mut entity = ctx.repository.find_by_id(input).await?
            .ok_or_else(|| DomainError::NotFound { id: input.to_string() })?;

        entity.archive()?;
        ctx.repository.save(&entity).await?;

        Ok(EntityDto {
            id: entity.id,
            name: entity.name,
            status: format!("{:?}", entity.status),
            created_at: entity.created_at,
            updated_at: entity.updated_at,
        })
    }
}
